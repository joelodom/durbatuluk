#summary An overview of the Durbatulûk design

= Protocol Design =

The following diagram depicts how Durbatulûk commands are encapsulated in various layers of overhead used in message handling and to provide security.

'<img width="40%" src="http://durbatuluk.googlecode.com/svn/images/Durbatuluk%20Protocol%20Diagram.png">'

The fundamental unit of the Durbatulûk protocol is the `DurbatulukMessage`, defined as

{{{
message DurbatulukMessage {
  required string type = 1;
  required string contents = 2;
  required uint64 sequence_number = 3;
}
}}}

The only currently implemented message type is `ShellExec`, though future message types are likely.  The contents field of a `DurbatulukMessage` contains the message contents as a string.  In the case of a `ShellExec` message, this is a command to pass to the command interpreter.

The sequence number is used to prevent replay attacks.  Sequence numbers need not be strictly sequential (they could be based on the number of seconds since some epoch).  A Durbatulûk client will drop `ShellExec` messages if the sequence number of the message is not greater than the last sequence number processed.  (Commanders should set their last sequence number processed to `2^64^ - 1` as a safety precaution against accidentally processing `ShellExec` messages.  There is a provision to allow commanders to allow specific sequence numbers in order to process replies from clients, but this feature is under development.)  Sequence number information is saved in a sequence file so that it persists between Durbatulûk executions.

Durbatulûk messages are encapsulated in an `EncryptedMessage`, defined as

{{{
message EncryptedMessage {
  required RSAKey recipient = 1;
  required bytes encrypted_key = 2;
  required bytes encrypted_contents = 3;
}
}}}

The recipient's public RSA key is included in the encrypted message so that recipients can identify messaged intended for them.  The `RSAKey` message type, used in `EncryptedMessage`, will be explained below.

When a Durbatulûk client verifies that an encrypted message is intended for it, the client uses the RSA decryption algorithm to decrypt the encrypted symmetric key, which in turn is used to decrypt the encrypted contents of the encrypted message.  These encrypted contents are the serialized form of the encapsulated `DurbatulukMessage`.

Encrypted messages are encapsulated in a `SignedMessage`, defined as

{{{
message SignedMessage {
  required RSAKey sender = 1;
  required bytes contents = 2;
  required bytes signature = 3;
}
}}}

The sender field of the signed message is the public signing key of the sender of the message.  This allows clients to verify that the contents of the message are authentic.

When a client first receives a message, it verifies that the sender of the message is an authorized sender by checking the sender public key against the allowed senders in the client's Durbatulûk configuration file.  If this is true, signature verification and decryption take place.  After this process, the client verifies that the sender of the message is allowed to send the particular message type in the encapsulated `DurbatulukMessage`.

After a commander generates a signed message, the message is encoded using base64 for convenience.  There is a large amount of overhead after encapsulation of a single command as described above, but most of this is due to the inclusion of public keys in the messages and does not grow faster than the size of the message.  Encryption algorithm randomization notwithstanding, the `ShellExec` command "echo hello" grows to:

{{{
<durbatuluk>CogCCoAC9bKbkyo+sKhlu5HPHZYpIZVntKY6YesnXDWsjbyMnEYCnqkCjBVAPKYLCGvUln560alF/Ax0DwI24gl0rda8CsdeYkldHbhYIKVJsE3wcKBo04iIjeR/Bco7MkTWI+cEeM8z0zU6MO4YcNm2r2/lOuVHoYO/IPQlt4XYtlodE7xwVduAd3viSN2ZTV2RwDMp39pWju9WxfZVHrFN5ELkCiRQl/CXFzsz8MnCA7sdvk7cRIjYKLpnY9d2wgjWETC3CBBEI6AIjAx6fmF8TPw1v5NXO5WW+fjNOruMvjgqe0syuC56SMpggFaBFNYH3b4bFL9/m2aUA29rUldpMzZElxIDAQABErAECogCCoACwMIeIgNzjr8QILQ+RDVCm8WztSvOOVzN8ULYwqYu/Gm/MqD4HL8A2D8vtd8lNFlklyvO+HHT8gRhldccBh5vQop3aIHIyx0sL4eu8dFDpBqziYPZKis0OUAE61+ahMY+31rKnxUqjn6wbVFcIziSC3fxUp506S9eBD5+ioe7yaecNIsiC+6AB75UT/GUVm+ysa1o1kXZoquBBUf9c3fp9QgRvGhMxWh+q8FaRV8HM8VEmlzr0OHpokgjSqFV8XcgicfQKlxC1kCQ2RzrxDp95cVnXADgSOEzR1566m28fV/tbQ0o1V9BVunJaT6S7Dm9itd2nsL7P6enDhmfs+N2/xIDAQABEoACUWFL5fGphKdwSccZMhHahl+ppTqbO0yaWAmMJ8EdJRY5lkIvcNhtjorJZAJuyYfqGsC/OLpgRFMVL5d9E6tl1na0Db093DBbwtNhknlD1z6ofKoPmY1vqB5Hcne1xmF/6Uo4l2u5HyZm5toygJ7ajN+8XeJ/5RybYy0UsY/VIMZR+SvO7r5A4qFRhKbLoVkASOYdfMcjGvqLgrDeKSNkdHzhOFoklINAfIyC9oC0esVL77no24svpmLt/YFBncyotER3JAUIg6LqENY/lyvMxlWGWTddXUeGmrjvTEtwJDOjjRYxUWfILrDE9Ejx0cKw/bbi0HxT6VGgQS1RvK7OKBogVXpeAo+LRnK/3ZNO9yVgE8Zymamj14nK+YxFdqPPe6wagAJwBZ3HSvVeZ+a60CuV5Gg6A4KBuJ2DieS8LjVFZaMQrRjU7VPeZFbj8h2tpcTefVvaS1+1Zbb0S8wPN4D25YodCsbsoJnrHNwwLZmNFnRKp2SBHk6KFuTze/DG6Wjpynwap1ETqRM/XyExYsVEsi7ZH6J4mp3gK58H3Hoeh+dFgjnVHZVN2WhsHKRAlAFLELVADMHEHRfaqI1GhSqQJULIcuU0mfqxdvhLCgIolGkE8p3E0uIZsX9//yB3qCTVHLdqtIj9Tp+XhQbE9dLKmPdZjfEaYN/vIDP6AIl6GsGGOyca0x8D5xjikn24lZIhGgCrfsdRg2BSpdrfj85W2Wq4</durbatuluk>
}}}

The inclusion of the XML-like starting and ending tags are for convenience in embedding messages in XML, should the need arise.

The `RSAKey` message, used for storing public and private RSA keys for encryption and signing  is defined as

{{{
message RSAKey {
  // public parameters
  required bytes n = 1;
  required bytes e = 2;

  // private parameters
  optional bytes d = 3;
  optional bytes p = 4;
  optional bytes q = 5;
  optional bytes dmp1 = 6;
  optional bytes dmq1 = 7;
  optional bytes iqmp = 8;
}
}}}

RSA keys in signed messages and in encrypted messages do not include the optional parameters, but these are included when the structure is serialized to private key files.

= Modular Architecture =

As of the time of this writing, Durbatulûk is broken into one main file (durbatuluk.cc) and ten modules.  Each module is coded as a separate C++ static class. _The implementations below may have changed slightly since the writing of this document, so please consult the source code for the latest versions._

== Message Handler Module ==

The message handler handles Durbatulûk messages after they have been decrypted.  There is one main function on this module, `HandleMessage`, which processes an incoming message and generates an output message.  An optional callback function allows users of the message handler to process separately the type and contents of a message.  This is the module to change to make simple Durbatulûk customizations.  See CustomizingDurbatuluk.

{{{
typedef bool (*MessageHandlerCallback)(
  const std::string& type, const std::string& contents);

static bool HandleMessage(const DurbatulukMessage& input,
  DurbatulukMessage& output, MessageHandlerCallback callback = nullptr);
}}}

== Cryptographic Module ==

The cryptographic module is the main module for performing cryptographic functions.  It is used by the main functions and other modules to perform the functions noted in the comments below.

{{{
// methods to convert between OpenSSL and protocol buffers
static bool ExtractPublicRSAKey(RSA* rsa, RSAKey& public_key);
static bool ExtractPrivateRSAKey(RSA* rsa, RSAKey& private_key);
static bool ImportRSAKey(const RSAKey& rsa_key, RSA* rsa);

// methods to create and to verify a protocol buffers SignedMessage
static bool CreateSignedMessage(
  std::string& contents, RSA* rsa, SignedMessage& signed_message);
static bool VerifySignedMessage(SignedMessage& signed_message);

// methods to encrypt and to decrypt a protocol buffers EncryptedMessage
static bool EncryptMessage(RSAKey& recipient_public_key,
  std::string& contents, EncryptedMessage& encrypted_message);
static bool DecryptMessage(RSA* rsa, EncryptedMessage& encrypted_message,
  std::string& decrypted);

// method to extract a hash of a public key
static bool HashRSAKey(const RSAKey& key, std::string& encoded_hash);
}}}

== Processing Engine ==

The processing engine provides methods to bundle common Durbatulûk patterns into individual methods.

{{{
// method to generate a DurbatulukMessage
static bool GenerateEncodedDurbatulukMessage(const std::string& type,
  const std::string& contents, RSAKey& recipient_public_key,
  RSA* sender_signing_key, std::string& encoded_message,
  unsigned long long& sequence_number);

// method to handle an encoded message with message handler
// (doesn't generate encoded response, but passes on message handler output
// and callback)
static bool HandleIncomingEncodedMessage(
  std::string& encoded_incoming, RSA* recipient_private_encryption_key,
  DurbatulukMessage& output, MessageHandlerCallback callback = nullptr);

// methods to perform a full Durbatuluk circle of encryption and encoding
static bool EncryptSignAndEncode(std::string& message,
  RSAKey& recipient_public_key, RSA* sender_signing_key,
  std::string& encoded);
static bool DecodeVerifyAndDecrypt(std::string& encoded,
  RSA* recipient_private_encryption_key, DurbatulukMessage& message);
}}}

== Encoding Module ==

The encoding module performs base64 encoding and decoding.

{{{
static bool EncodeMessage(const std::string& input, std::string& output);
static bool DecodeMessage(const std::string& input, std::string& output);
}}}

== Sequence Manager Module ==

The sequence manager encapsulates handling of sequence numbers, which are used to prevent replay attacks.  This module interacts with the sequence number file to persist sequence numbers between Durbatulûk sessions.

{{{
static unsigned long long GetNextSequenceNumber();

// returns true if allowed, false if disallowed or error
static bool IsSequenceNumberAllowed(unsigned long long n);

static bool SetMinimumAllowedSequenceNumber(unsigned long long n);
static bool AddToAllowedSequenceNumbers(unsigned long long n);
static bool RemoveFromAllowedSequenceNumbers(unsigned long long n);

static bool ResetSequenceNumberFile();
}}}

== Configuration Manager ==

The configuration manager parses the configuration file and provides an interface to the parameters in the configuration file.

{{{
static bool ReadConfigurationFile(std::string& config_file_name);

static bool GetSequenceNumberFileName(std::string& file_name);

static bool GetConfigurationFileName(std::string& file_name);
static bool SetConfigurationFileName(std::string& file_name);

static bool GetPostMessageURL(std::string& url);
static bool GetFetchMessageURL(std::string& url);
static bool GetMySigningKeyName(std::string& name);
static bool GetMyEncryptionKeyName(std::string& name);

// The idea is to allow an initial check of the sender, followed
// by a check of the sender and message type pair.  This double
// check reduces attack surface.
static bool IsSenderAllowed(const RSAKey& sender);
static bool IsSenderAllowedToSendMessageType(
  const RSAKey& sender, const std::string& type);

// AllowSender is mostly for testing purposes
static bool AllowSender(RSA* rsa, const std::string& type);
}}}

== !KeyFile Module ==

The key file module reads and writes Durbatulûk key files.

{{{
static bool WriteKeyFiles(const std::string& key_name, RSA* rsa);
static bool ReadPublicKeyFile(const std::string& key_name, RSAKey& key);
static bool ReadPrivateKeyFile(const std::string& key_name, RSAKey& key);
}}}

== !NetFetcher Module ==

The net fetcher module wraps `libcurl` to allow for easy HTTP gets and puts so that Durbatulûk clients and commanders can interact with Durbatulûk servers.

{{{
static bool FetchURL(const std::string& url, std::string& contents);

// Input command should not be escaped.  For example,
// <durbatuluk>Cog/5+8/sFo==</durbatuluk> as input command
// will be posted as
// message=%3Cdurbatuluk%3ECog%2F5%2B8%2FsFo%3D%3D%3C%2Fdurbatuluk%3E
static bool PostMessageToURL(
  const std::string& url, const std::string& message);
}}}

== Logger Module ==

The logger module is for logging different types messages.  The minimum severity of log messages may be set via the configuration file.

{{{
enum LoggerSeverity { DEBUG, INFO, ERROR, NONE };

static void LogMessage(LoggerSeverity severity,
  const std::string& component, const std::string& message);

// this version empties the stringstream so that it can be reused
static void LogMessage(LoggerSeverity severity,
  const std::string& component, std::stringstream& message);

static void SetMinLoggingSeverity(LoggerSeverity severity);
}}}

== Utility Module ==

Miscellaneous utility methods should be placed here.

{{{
static bool WriteToFile(
  const std::string& file_name, const std::string& data);
}}}

= Command Line Parameters & Configuration File =

In the current implementation of Durbatulûk, commanders use a combination of command line parameters and `stdio` to specify inputs to the system that are likely to change for each run of Durbatulûk.  Parameters that are static for a particular commander or client are stored in a configuration file, which is currently always named `durbatuluk.conf`.

For details of the command line parameters and configuration file, see GettingStarted.  The [http://durbatuluk.googlecode.com/svn/trunk/durbatuluk.conf default configuration file that ships with Durbatulûk] also contains comments that explain the configuration options.  Running Durbatulûk with no command line parameters will list the available parameters and their usage.

The configuration file, which may contain comments, is always read by Durbatulûk at startup.  If reading or parsing the configuration file fails, Durbatulûk will exit with an error.

= Extensibility =

See CustomizingDurbatuluk.